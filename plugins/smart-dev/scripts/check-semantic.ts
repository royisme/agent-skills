#!/usr/bin/env bun
/**
 * Semantic Check Result Validator (Track B)
 *
 * Validates and summarizes semantic-check.json generated by the
 * semantic-checker agent (in-session, no external API).
 *
 * Usage:
 *   bun run check-semantic.ts --feature <feature-name>
 */

import { existsSync, readFileSync } from 'fs';
import { join } from 'path';

interface SemanticCheck {
  ok: boolean;
  confidence: number;
  reason: string;
  evidence: Array<{
    claim: string;
    citation: string;
  }>;
  gaps: string[];
  skipped?: boolean;
}

const args = process.argv.slice(2);
let featureName = '';

for (let i = 0; i < args.length; i++) {
  if (args[i] === '--feature' && i + 1 < args.length) {
    featureName = args[i + 1];
    i++;
  }
}

if (!featureName) {
  console.error('Usage: bun run check-semantic.ts --feature <feature-name>');
  process.exit(1);
}

const specDir = join('.works/spec', featureName);
const outputPath = join(specDir, 'semantic-check.json');

if (!existsSync(outputPath)) {
  console.error(`Error: semantic-check.json not found at ${outputPath}`);
  console.error('Run the semantic-checker agent in the smart-dev workflow to generate it.');
  process.exit(1);
}

const raw = readFileSync(outputPath, 'utf-8');
const result = JSON.parse(raw) as SemanticCheck;

if (typeof result.ok !== 'boolean') {
  console.error('Error: semantic-check.json is missing required fields (ok).');
  process.exit(1);
}

console.log(`\nSemantic Check: ${result.ok ? 'PASS ✓' : 'FAIL ✗'}`);
console.log(`Confidence: ${result.confidence}%`);
console.log(`Reason: ${result.reason}`);

if (result.evidence?.length) {
  console.log('\nEvidence:');
  result.evidence.forEach((entry, index) => {
    console.log(`  ${index + 1}. ${entry.claim}`);
    console.log(`     Citation: "${entry.citation.substring(0, 100)}..."`);
  });
}

if (result.gaps?.length) {
  console.log('\nGaps:');
  result.gaps.forEach(gap => {
    console.log(`  - ${gap}`);
  });
}

process.exit(result.ok ? 0 : 1);
